<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden of Eeden Isometric Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            background: #87ceeb;
        }
    </style>
</head>
<body>
<script>
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    document.body.appendChild(canvas);

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const TILE_SIZE = 64; // Size of each isometric tile
    const mapWidth = 10;
    const mapHeight = 10;

    const player = {
        x: 5,
        y: 5,
        speed: 0.1,
        frame: 0,
        state: 'idle', // Can be 'idle' or 'moving'
        texture: new Image()
    };

    const npcs = [
        { x: 3, y: 3, state: 'idle', frame: 0, texture: new Image(), message: "Welcome to the Garden of Eeden!" },
        { x: 7, y: 2, state: 'idle', frame: 0, texture: new Image(), message: "This is a place of wonder and wisdom." },
        { x: 6, y: 6, state: 'idle', frame: 0, texture: new Image(), message: "Seek knowledge, and you shall find it." }
    ];

    const map = [];

    const textures = {
        grass: new Image()
    };

    textures.grass.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/Isometric_MedievalFantasy_Tiles.png'; // Grass tileset from GitHub
    player.texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/player_idle.png'; // Replace with player idle texture

    npcs[0].texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/npc1_idle.png';
    npcs[1].texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/npc2_idle.png';
    npcs[2].texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/npc3_idle.png';

    for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
            map.push({ x, y });
        }
    }

    function drawTile(x, y, texture, cropX = 16, cropY = 0, cropWidth = 16, cropHeight = 16) {
        // Grass tile is at (16, 0) in the spritesheet
        const isoX = (x - y) * TILE_SIZE / 2 + canvas.width / 2;
        const isoY = (x + y) * TILE_SIZE / 4 + canvas.height / 4;
        ctx.drawImage(texture, cropX, cropY, cropWidth, cropHeight, isoX, isoY, TILE_SIZE, TILE_SIZE);
    }

    function drawMap() {
        map.forEach(tile => {
            drawTile(tile.x, tile.y, textures.grass, 16, 0, 16, 16);
        });
    }

    function drawEntity(entity) {
        const isoX = (entity.x - entity.y) * TILE_SIZE / 2 + canvas.width / 2;
        const isoY = (entity.x + entity.y) * TILE_SIZE / 4 + canvas.height / 4;
        const frameX = Math.floor(entity.frame) * TILE_SIZE;
        ctx.drawImage(entity.texture, frameX, 0, TILE_SIZE, TILE_SIZE, isoX, isoY - TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
    }

    function drawPlayer() {
        drawEntity(player);
    }

    function drawNPCs() {
        npcs.forEach(drawEntity);
    }

    function checkCollision(entity) {
        return Math.floor(player.x) === entity.x && Math.floor(player.y) === entity.y;
    }

    function interactWithNPCs() {
        npcs.forEach(npc => {
            if (checkCollision(npc)) {
                alert(npc.message);
            }
        });
    }

    function updateFrames() {
        player.frame += 0.1;
        if (player.frame >= 4) player.frame = 0; // Assuming 4 frames per animation

        npcs.forEach(npc => {
            npc.frame += 0.05;
            if (npc.frame >= 4) npc.frame = 0; // Assuming 4 frames per NPC animation
        });
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        drawNPCs();
        drawPlayer();
        updateFrames();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
        player.state = 'moving';
        switch (e.key) {
            case 'ArrowUp':
            case 'w':
                player.y -= player.speed;
                break;
            case 'ArrowDown':
            case 's':
                player.y += player.speed;
                break;
            case 'ArrowLeft':
            case 'a':
                player.x -= player.speed;
                break;
            case 'ArrowRight':
            case 'd':
                player.x += player.speed;
                break;
        }
        interactWithNPCs();
    });

    window.addEventListener('keyup', () => {
        player.state = 'idle';
    });

    textures.grass.onload = () => {
        gameLoop();
    };
</script>
</body>
</html>
