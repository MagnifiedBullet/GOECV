<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden of Eeden Isometric Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            background: #87ceeb;
        }
    </style>
</head>
<body>
<script>
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    document.body.appendChild(canvas);

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const TILE_SIZE = 64; // Rendered tile size
    const TILE_SRC_SIZE = 32; // Original sprite size of tiles
    const mapWidth = 10;
    const mapHeight = 10;

    const player = {
        x: 5,
        y: 5,
        speed: 0.1,
        frame: 0,
        state: 'idle',
        texture: new Image()
    };

    const npcs = [
        { x: 3, y: 3, state: 'idle', frame: 0, texture: new Image(), message: "Welcome to the Garden of Eeden!" },
        { x: 7, y: 2, state: 'idle', frame: 0, texture: new Image(), message: "This is a place of wonder and wisdom." },
        { x: 6, y: 6, state: 'idle', frame: 0, texture: new Image(), message: "Seek knowledge, and you shall find it." }
    ];

    const map = [];

    const textures = {
        grass: new Image()
    };

    textures.grass.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/Isometric_MedievalFantasy_Tiles.png';
    player.texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/player_idle.png';

    npcs[0].texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/npc1_idle.png';
    npcs[1].texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/npc2_idle.png';
    npcs[2].texture.src = 'https://raw.githubusercontent.com/MagnifiedBullet/GOECV/main/Assets/npc3_idle.png';

    for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
            map.push({ x, y });
        }
    }

    function drawTile(x, y, texture, cropX = 0, cropY = 0) {
        const isoX = (x - y) * TILE_SIZE / 2 + canvas.width / 2;
        const isoY = (x + y) * TILE_SIZE / 4 + canvas.height / 4;

        ctx.drawImage(
            texture,
            cropX, cropY, // Cropping coordinates from the tileset
            TILE_SRC_SIZE, TILE_SRC_SIZE, // Cropping dimensions (32x32)
            isoX, isoY, // Placement on canvas
            TILE_SIZE, TILE_SIZE // Scaled tile size (64x64)
        );
    }

    function drawMap() {
        map.forEach(tile => {
            // Assuming the grass tile is located at (32, 0) in the spritesheet (adjust this as needed)
            drawTile(tile.x, tile.y, textures.grass, 32, 0);
        });
    }

    function drawEntity(entity) {
        const isoX = (entity.x - entity.y) * TILE_SIZE / 2 + canvas.width / 2;
        const isoY = (entity.x + entity.y) * TILE_SIZE / 4 + canvas.height / 4;
        const frameX = Math.floor(entity.frame) * TILE_SRC_SIZE;

        ctx.drawImage(
            entity.texture,
            frameX, 0, // Assuming animation frames are horizontal
            TILE_SRC_SIZE, TILE_SRC_SIZE,
            isoX, isoY - TILE_SIZE / 2, // Adjust to position sprite above ground
            TILE_SIZE, TILE_SIZE
        );
    }

    function drawPlayer() {
        drawEntity(player);
    }

    function drawNPCs() {
        npcs.forEach(drawEntity);
    }

    function checkCollision(entity) {
        return Math.floor(player.x) === entity.x && Math.floor(player.y) === entity.y;
    }

    function interactWithNPCs() {
        npcs.forEach(npc => {
            if (checkCollision(npc)) {
                alert(npc.message);
            }
        });
    }

    function updateFrames() {
        player.frame += 0.1;
        if (player.frame >= 4) player.frame = 0; // Assuming 4 frames per animation

        npcs.forEach(npc => {
            npc.frame += 0.05;
            if (npc.frame >= 4) npc.frame = 0; // Assuming 4 frames per NPC animation
        });
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        drawNPCs();
        drawPlayer();
        updateFrames();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
        player.state = 'moving';
        switch (e.key) {
            case 'ArrowUp':
            case 'w':
                player.y -= player.speed;
                break;
            case 'ArrowDown':
            case 's':
                player.y += player.speed;
                break;
            case 'ArrowLeft':
            case 'a':
                player.x -= player.speed;
                break;
            case 'ArrowRight':
            case 'd':
                player.x += player.speed;
                break;
        }
        interactWithNPCs();
    });

    window.addEventListener('keyup', () => {
        player.state = 'idle';
    });

    textures.grass.onload = () => {
        gameLoop();
    };
</script>
</body>
</html>
